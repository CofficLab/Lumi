import Foundation
import AppKit
import OSLog
import MagicKit

@MainActor
class CacheCleanerService: ObservableObject, SuperLog {
    static let shared = CacheCleanerService()

    @Published var categories: [CacheCategory] = []
    @Published var isScanning = false
    @Published var scanProgress: String = ""

    // MARK: - Predefined scan rules
    
    // Use closure to delay path retrieval (because homeDirectory might change, although unlikely)
    private var scanRules: [(CacheCategory.SafetyLevel, String, String, String, String, [String])] {
        let home = FileManager.default.homeDirectoryForCurrentUser.path
        return [
            // level, id, name, desc, icon, paths
            (.safe, "user_app_cache", String(localized: "App Cache"), String(localized: "Clear temporary files generated by applications"), "app.badge", ["\(home)/Library/Caches"]),
            (.safe, "browser_cache", String(localized: "Browser Cache"), String(localized: "Clear Chrome, Safari, Firefox and other browser caches"), "safari", [
                "\(home)/Library/Caches/Google/Chrome",
                "\(home)/Library/Caches/com.apple.Safari",
                "\(home)/Library/Caches/Firefox"
            ]),
            (.safe, "dev_cache", String(localized: "Developer Tool Cache"), String(localized: "Clear Xcode DerivedData, Archives, and package manager caches"), "hammer", [
                "\(home)/Library/Developer/Xcode/DerivedData",
                "\(home)/Library/Developer/Xcode/Archives",
                "\(home)/.npm/_cacache",
                "\(home)/.cargo/registry"
            ]),
            (.medium, "system_logs", String(localized: "System Logs"), String(localized: "Clear system runtime log files"), "doc.text", [
                "\(home)/Library/Logs"
            ]),
            (.safe, "trash", String(localized: "Trash"), String(localized: "Empty files in the trash"), "trash", [
                "\(home)/.Trash"
            ])
        ]
    }

    // MARK: - Public API

    func scanCaches() async {
        isScanning = true
        scanProgress = String(localized: "Initializing...")
        var results: [CacheCategory] = []
        
        // Parallel scanning of each category
        await withTaskGroup(of: CacheCategory?.self) { group in
            for (level, id, name, desc, icon, paths) in scanRules {
                group.addTask {
                    await self.scanCategory(id: id, name: name, desc: desc, icon: icon, paths: paths, level: level)
                }
            }
            
            for await category in group {
                if let category = category {
                    results.append(category)
                }
            }
        }
        
        self.categories = results.sorted { $0.safetyLevel < $1.safetyLevel }
        self.isScanning = false
        self.scanProgress = ""
    }
    
    func cleanup(paths: [CachePath]) async throws -> Int64 {
        var freedSpace: Int64 = 0
        
        for item in paths {
            do {
                try FileManager.default.removeItem(atPath: item.path)
                freedSpace += item.size
            } catch {
                os_log(.error, "\(self.t)Cleanup failed: \(item.path) - \(error.localizedDescription)")
            }
        }
        
        // Rescan to update status
        await scanCaches()
        return freedSpace
    }

    // MARK: - Private Implementation
    
    private func scanCategory(id: String, name: String, desc: String, icon: String, paths: [String], level: CacheCategory.SafetyLevel) async -> CacheCategory? {
        var cachePaths: [CachePath] = []
        
        for path in paths {
            // Update progress (Note: on main actor, might cause stutter if too frequent, but acceptable here)
            await MainActor.run {
                self.scanProgress = String(localized: "Scanning \(name)...")
            }
            
            if let info = await getPathInfo(path) {
                // Special handling: if it's ~/Library/Caches, we don't want to delete the entire folder, but list subfolders
                if path.hasSuffix("/Library/Caches") {
                    let subPaths = await scanSubDirectories(at: path)
                    cachePaths.append(contentsOf: subPaths)
                } else {
                    cachePaths.append(CachePath(
                        path: path,
                        name: URL(fileURLWithPath: path).lastPathComponent,
                        description: path,
                        size: info.size,
                        fileCount: info.count,
                        canDelete: true
                    ))
                }
            }
        }
        
        if cachePaths.isEmpty {
            return nil
        }
        
        return CacheCategory(
            id: id,
            name: name,
            description: desc,
            icon: icon,
            paths: cachePaths,
            safetyLevel: level
        )
    }
    
    private func scanSubDirectories(at path: String) async -> [CachePath] {
        let url = URL(fileURLWithPath: path)
        var results: [CachePath] = []
        
        guard let contents = try? FileManager.default.contentsOfDirectory(at: url, includingPropertiesForKeys: nil, options: [.skipsHiddenFiles]) else {
            return []
        }
        
        for content in contents {
            if let info = await getPathInfo(content.path), info.size > 0 {
                results.append(CachePath(
                    path: content.path,
                    name: content.lastPathComponent,
                    description: String(localized: "App Cache"),
                    size: info.size,
                    fileCount: info.count,
                    canDelete: true
                ))
            }
        }
        
        return results.sorted { $0.size > $1.size }
    }
    
    private func getPathInfo(_ path: String) async -> (size: Int64, count: Int)? {
        let fileManager = FileManager.default
        var isDir: ObjCBool = false
        
        guard fileManager.fileExists(atPath: path, isDirectory: &isDir) else {
            return nil
        }
        
        if !isDir.boolValue {
            // Single file
            if let attrs = try? fileManager.attributesOfItem(atPath: path),
               let size = attrs[.size] as? Int64 {
                return (size, 1)
            }
            return nil
        }
        
        // Directory: recursively calculate size
        // For performance, we don't use DiskService's full scan here, but a quick traversal
        // Or reuse DiskService.scan but don't build a tree?
        // For simplicity, use Enumerator
        
        return await Task.detached {
            var localSize: Int64 = 0
            var localCount = 0
            
            guard let enumerator = fileManager.enumerator(atPath: path) else { return nil }
            
            // FileManager.DirectoryEnumerator is not thread-safe and not Sendable,
            // but we are inside a detached Task with a local instance created on that thread (if fileManager is thread safe).
            // Actually FileManager.default is thread-safe.
            // However, makeIterator() availability in async context is the issue.
            // We can iterate using while loop with nextObject() which is the ObjC way and avoids Sequence conformance issues in async
            
            while let _ = enumerator.nextObject() {
                if let fileAttrs = enumerator.fileAttributes,
                   let fileSize = fileAttrs[.size] as? Int64 {
                    localSize += fileSize
                    localCount += 1
                }
            }
            return (localSize, localCount)
        }.value
    }
}
